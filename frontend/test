// lib/apollo-client.ts
import { ApolloClient, InMemoryCache, createHttpLink, from } from '@apollo/client';
import { setContext } from '@apollo/client/link/context';
import { onError } from '@apollo/client/link/error';
import { getCookie, setCookie, deleteCookie } from 'cookies-next';
import { refreshToken } from './auth-service';

const httpLink = createHttpLink({
  uri: process.env.NEXT_PUBLIC_GRAPHQL_ENDPOINT,
  credentials: 'include',
});

const authLink = setContext(async (_, { headers }) => {
  const token = getCookie('accessToken');
  
  return {
    headers: {
      ...headers,
      authorization: token ? `Bearer ${token}` : '',
    }
  };
});

const errorLink = onError(({ graphQLErrors, networkError, operation, forward }) => {
  if (graphQLErrors) {
    for (let err of graphQLErrors) {
      switch (err.extensions?.code) {
        case 'UNAUTHENTICATED':
          // Token expired, try to refresh
          return refreshToken().then((newToken) => {
            if (newToken) {
              setCookie('accessToken', newToken);
              // Retry the operation with new token
              const oldHeaders = operation.getContext().headers;
              operation.setContext({
                headers: {
                  ...oldHeaders,
                  authorization: `Bearer ${newToken}`,
                }
              });
              return forward(operation);
            } else {
              // Refresh failed, redirect to login
              deleteCookie('accessToken');
              deleteCookie('refreshToken');
              window.location.href = '/login';
            }
          });
      }
    }
  }

  if (networkError) {
    console.error(`Network error: ${networkError}`);
  }
});

export const apolloClient = new ApolloClient({
  link: from([errorLink, authLink, httpLink]),
  cache: new InMemoryCache(),
  defaultOptions: {
    watchQuery: {
      errorPolicy: 'all',
    },
    query: {
      errorPolicy: 'all',
    },
  },
});

// lib/auth-service.ts
import { getCookie, setCookie, deleteCookie } from 'cookies-next';
import { apolloClient } from './apollo-client';
import { gql } from '@apollo/client';

const REFRESH_TOKEN_MUTATION = gql`
  mutation RefreshToken($refreshToken: String!) {
    refreshToken(refreshToken: $refreshToken) {
      accessToken
      refreshToken
      user {
        id
        email
        name
      }
    }
  }
`;

const REVOKE_TOKEN_MUTATION = gql`
  mutation RevokeToken($refreshToken: String!) {
    revokeToken(refreshToken: $refreshToken)
  }
`;

export const refreshToken = async (): Promise<string | null> => {
  try {
    const refresh = getCookie('refreshToken');
    if (!refresh) return null;

    const { data } = await apolloClient.mutate({
      mutation: REFRESH_TOKEN_MUTATION,
      variables: { refreshToken: refresh },
    });

    if (data?.refreshToken) {
      setCookie('accessToken', data.refreshToken.accessToken, {
        maxAge: 15 * 60, // 15 minutes
        httpOnly: false,
        secure: process.env.NODE_ENV === 'production',
        sameSite: 'strict',
      });
      
      setCookie('refreshToken', data.refreshToken.refreshToken, {
        maxAge: 7 * 24 * 60 * 60, // 7 days
        httpOnly: false,
        secure: process.env.NODE_ENV === 'production',
        sameSite: 'strict',
      });

      return data.refreshToken.accessToken;
    }
    
    return null;
  } catch (error) {
    console.error('Token refresh failed:', error);
    return null;
  }
};

export const revokeToken = async (): Promise<void> => {
  try {
    const refresh = getCookie('refreshToken');
    if (refresh) {
      await apolloClient.mutate({
        mutation: REVOKE_TOKEN_MUTATION,
        variables: { refreshToken: refresh },
      });
    }
  } catch (error) {
    console.error('Token revocation failed:', error);
  } finally {
    deleteCookie('accessToken');
    deleteCookie('refreshToken');
  }
};

export const logout = async (): Promise<void> => {
  await revokeToken();
  await apolloClient.clearStore();
  window.location.href = '/login';
};

// contexts/auth-context.tsx
'use client';

import React, { createContext, useContext, useEffect, useState, ReactNode } from 'react';
import { useQuery, useMutation } from '@apollo/client';
import { gql } from '@apollo/client';
import { getCookie, setCookie, deleteCookie } from 'cookies-next';
import { refreshToken, logout as logoutService } from '@/lib/auth-service';

const ME_QUERY = gql`
  query Me {
    me {
      id
      email
      name
      role
    }
  }
`;

const LOGIN_MUTATION = gql`
  mutation Login($email: String!, $password: String!) {
    login(email: $email, password: $password) {
      accessToken
      refreshToken
      user {
        id
        email
        name
        role
      }
    }
  }
`;

const REGISTER_MUTATION = gql`
  mutation Register($email: String!, $password: String!, $name: String!) {
    register(email: $email, password: $password, name: $name) {
      accessToken
      refreshToken
      user {
        id
        email
        name
        role
      }
    }
  }
`;

interface User {
  id: string;
  email: string;
  name: string;
  role: string;
}

interface AuthContextType {
  user: User | null;
  loading: boolean;
  login: (email: string, password: string) => Promise<boolean>;
  register: (email: string, password: string, name: string) => Promise<boolean>;
  logout: () => Promise<void>;
  isAuthenticated: boolean;
}

const AuthContext = createContext<AuthContextType | undefined>(undefined);

export const useAuth = (): AuthContextType => {
  const context = useContext(AuthContext);
  if (!context) {
    throw new Error('useAuth must be used within an AuthProvider');
  }
  return context;
};

interface AuthProviderProps {
  children: ReactNode;
  initialUser?: User | null;
}

export const AuthProvider: React.FC<AuthProviderProps> = ({ 
  children, 
  initialUser = null 
}) => {
  const [user, setUser] = useState<User | null>(initialUser);
  const [initialized, setInitialized] = useState(!!initialUser);

  const { data, loading: queryLoading, refetch } = useQuery(ME_QUERY, {
    skip: !getCookie('accessToken') || !!initialUser,
    errorPolicy: 'all',
    onCompleted: (data) => {
      if (data?.me) {
        setUser(data.me);
      }
      setInitialized(true);
    },
    onError: async (error) => {
      if (error.graphQLErrors.some(e => e.extensions?.code === 'UNAUTHENTICATED')) {
        const newToken = await refreshToken();
        if (newToken) {
          refetch();
        } else {
          setUser(null);
          setInitialized(true);
        }
      } else {
        setInitialized(true);
      }
    }
  });

  const [loginMutation] = useMutation(LOGIN_MUTATION);
  const [registerMutation] = useMutation(REGISTER_MUTATION);

  const login = async (email: string, password: string): Promise<boolean> => {
    try {
      const { data } = await loginMutation({
        variables: { email, password },
      });

      if (data?.login) {
        setCookie('accessToken', data.login.accessToken, {
          maxAge: 15 * 60, // 15 minutes
          httpOnly: false,
          secure: process.env.NODE_ENV === 'production',
          sameSite: 'strict',
        });
        
        setCookie('refreshToken', data.login.refreshToken, {
          maxAge: 7 * 24 * 60 * 60, // 7 days
          httpOnly: false,
          secure: process.env.NODE_ENV === 'production',
          sameSite: 'strict',
        });

        setUser(data.login.user);
        return true;
      }
      return false;
    } catch (error) {
      console.error('Login failed:', error);
      return false;
    }
  };

  const register = async (email: string, password: string, name: string): Promise<boolean> => {
    try {
      const { data } = await registerMutation({
        variables: { email, password, name },
      });

      if (data?.register) {
        setCookie('accessToken', data.register.accessToken, {
          maxAge: 15 * 60, // 15 minutes
          httpOnly: false,
          secure: process.env.NODE_ENV === 'production',
          sameSite: 'strict',
        });
        
        setCookie('refreshToken', data.register.refreshToken, {
          maxAge: 7 * 24 * 60 * 60, // 7 days
          httpOnly: false,
          secure: process.env.NODE_ENV === 'production',
          sameSite: 'strict',
        });

        setUser(data.register.user);
        return true;
      }
      return false;
    } catch (error) {
      console.error('Registration failed:', error);
      return false;
    }
  };

  const logout = async (): Promise<void> => {
    await logoutService();
    setUser(null);
  };

  const loading = queryLoading || !initialized;
  const isAuthenticated = !!user;

  return (
    <AuthContext.Provider
      value={{
        user,
        loading,
        login,
        register,
        logout,
        isAuthenticated,
      }}
    >
      {children}
    </AuthContext.Provider>
  );
};

// middleware.ts
import { NextResponse } from 'next/server';
import type { NextRequest } from 'next/server';
import { jwtVerify } from 'jose';

const secret = new TextEncoder().encode(process.env.JWT_SECRET);

// Routes that don't require authentication (public routes)
const publicRoutes = ['/login', '/register'];

// Additional static/system routes that should be allowed
const systemRoutes = ['/api/', '/_next/', '/favicon.ico', '/robots.txt', '/sitemap.xml'];

async function verifyToken(token: string): Promise<boolean> {
  try {
    await jwtVerify(token, secret);
    return true;
  } catch {
    return false;
  }
}

export async function middleware(request: NextRequest) {
  const { pathname } = request.nextUrl;
  const accessToken = request.cookies.get('accessToken')?.value;
  const refreshToken = request.cookies.get('refreshToken')?.value;

  // Check if current route is public (login/register)
  const isPublicRoute = publicRoutes.some(route => 
    pathname.startsWith(route)
  );
  
  // Check if current route is system route
  const isSystemRoute = systemRoutes.some(route => 
    pathname.startsWith(route)
  );

  // If it's a system route, allow access
  if (isSystemRoute) {
    return NextResponse.next();
  }

  // If user has access token, verify it
  if (accessToken) {
    const isValidToken = await verifyToken(accessToken);
    
    if (isValidToken) {
      // Valid token - redirect away from auth routes to dashboard
      if (isPublicRoute) {
        const dashboardUrl = new URL('/dashboard', request.url);
        return NextResponse.redirect(dashboardUrl);
      }
      // Allow access to all other routes (everything is protected except login/register)
      return NextResponse.next();
    }
  }

  // No valid access token, but has refresh token
  if (refreshToken && !accessToken && !isPublicRoute) {
    // For protected routes without access token, redirect to login with return URL
    const loginUrl = new URL('/login', request.url);
    loginUrl.searchParams.set('redirect', pathname);
    return NextResponse.redirect(loginUrl);
  }

  // No valid tokens
  if (!isPublicRoute) {
    // Redirect to login for all protected routes (everything except login/register)
    const loginUrl = new URL('/login', request.url);
    loginUrl.searchParams.set('redirect', pathname);
    return NextResponse.redirect(loginUrl);
  }

  // For public routes (login/register) without token, allow access
  return NextResponse.next();
}

export const config = {
  matcher: [
    /*
     * Match all request paths except for the ones starting with:
     * - api (API routes)
     * - _next/static (static files)
     * - _next/image (image optimization files)
     * - favicon.ico (favicon file)
     */
    '/((?!api|_next/static|_next/image|favicon.ico).*)',
  ],
};

// components/auth-guard.tsx
'use client';

import { useAuth } from '@/contexts/auth-context';
import { useRouter } from 'next/navigation';
import { useEffect, ReactNode } from 'react';

interface AuthGuardProps {
  children: ReactNode;
  requireAuth?: boolean;
  requiredRole?: string;
  fallback?: ReactNode;
}

export const AuthGuard: React.FC<AuthGuardProps> = ({
  children,
  requireAuth = true,
  requiredRole,
  fallback = <div>Loading...</div>,
}) => {
  const { user, loading, isAuthenticated } = useAuth();
  const router = useRouter();

  useEffect(() => {
    if (!loading) {
      if (requireAuth && !isAuthenticated) {
        router.push('/login');
        return;
      }

      if (requiredRole && user?.role !== requiredRole) {
        router.push('/unauthorized');
        return;
      }
    }
  }, [loading, isAuthenticated, user, requireAuth, requiredRole, router]);

  if (loading) {
    return <>{fallback}</>;
  }

  if (requireAuth && !isAuthenticated) {
    return <>{fallback}</>;
  }

  if (requiredRole && user?.role !== requiredRole) {
    return <>{fallback}</>;
  }

  return <>{children}</>;
};

// Higher-order component for page-level protection
export function withAuthGuard<P extends object>(
  Component: React.ComponentType<P>,
  options: Omit<AuthGuardProps, 'children'> = {}
) {
  return function AuthGuardedComponent(props: P) {
    return (
      <AuthGuard {...options}>
        <Component {...props} />
      </AuthGuard>
    );
  };
}

// lib/auth-hydration.ts
import { cookies } from 'next/headers';
import { apolloClient } from './apollo-client';
import { gql } from '@apollo/client';

const ME_QUERY = gql`
  query Me {
    me {
      id
      email
      name
      role
    }
  }
`;

export async function getServerSideAuth() {
  try {
    const cookieStore = cookies();
    const accessToken = cookieStore.get('accessToken')?.value;

    if (!accessToken) {
      return { user: null };
    }

    // Create a new Apollo client instance for server-side
    const { data } = await apolloClient.query({
      query: ME_QUERY,
      context: {
        headers: {
          authorization: `Bearer ${accessToken}`,
        },
      },
      fetchPolicy: 'network-only',
    });

    return {
      user: data?.me || null,
    };
  } catch (error) {
    console.error('Server-side auth error:', error);
    return { user: null };
  }
}

// app/providers.tsx
'use client';

import { ApolloProvider } from '@apollo/client';
import { apolloClient } from '@/lib/apollo-client';
import { AuthProvider } from '@/contexts/auth-context';

interface ProvidersProps {
  children: React.ReactNode;
  initialUser?: any;
}

export function Providers({ children, initialUser }: ProvidersProps) {
  return (
    <ApolloProvider client={apolloClient}>
      <AuthProvider initialUser={initialUser}>
        {children}
      </AuthProvider>
    </ApolloProvider>
  );
}

// app/layout.tsx
import { Providers } from './providers';
import { getServerSideAuth } from '@/lib/auth-hydration';

export default async function RootLayout({
  children,
}: {
  children: React.ReactNode;
}) {
  const { user } = await getServerSideAuth();

  return (
    <html lang="en">
      <body>
        <Providers initialUser={user}>
          {children}
        </Providers>
      </body>
    </html>
  );
}

// Example page implementations
// app/login/page.tsx
import { LoginForm } from '@/components/auth-forms';

export default function LoginPage() {
  return (
    <div className="min-h-screen flex items-center justify-center">
      <div className="max-w-md w-full space-y-8 p-8">
        <h2 className="text-3xl font-bold text-center">Sign In</h2>
        <LoginForm />
        <div className="text-center">
          <a href="/register" className="text-blue-500 hover:underline">
            Don't have an account? Register
          </a>
        </div>
      </div>
    </div>
  );
}

// app/register/page.tsx
import { RegisterForm } from '@/components/auth-forms';

export default function RegisterPage() {
  return (
    <div className="min-h-screen flex items-center justify-center">
      <div className="max-w-md w-full space-y-8 p-8">
        <h2 className="text-3xl font-bold text-center">Sign Up</h2>
        <RegisterForm />
        <div className="text-center">
          <a href="/login" className="text-blue-500 hover:underline">
            Already have an account? Sign In
          </a>
        </div>
      </div>
    </div>
  );
}

// components/auth-forms.tsx
'use client';

import { useAuth } from '@/contexts/auth-context';
import { useRouter, useSearchParams } from 'next/navigation';
import { Formik, Form, Field, ErrorMessage } from 'formik';
import * as Yup from 'yup';

// Validation schemas
const loginSchema = Yup.object({
  email: Yup.string().email('Invalid email').required('Email is required'),
  password: Yup.string().required('Password is required'),
});

const registerSchema = Yup.object({
  name: Yup.string().required('Name is required'),
  email: Yup.string().email('Invalid email').required('Email is required'),
  password: Yup.string().min(6, 'Password must be at least 6 characters').required('Password is required'),
});

export function LoginForm() {
  const { login } = useAuth();
  const router = useRouter();
  const searchParams = useSearchParams();

  const handleSubmit = async (values: { email: string; password: string }, { setSubmitting, setStatus }: any) => {
    try {
      setStatus('');
      const success = await login(values.email, values.password);
      
      if (success) {
        const redirect = searchParams.get('redirect') || '/dashboard';
        router.push(redirect);
        router.refresh(); // Ensure proper navigation
      } else {
        setStatus('Login failed. Please check your credentials.');
      }
    } catch (error) {
      setStatus('An error occurred. Please try again.');
    } finally {
      setSubmitting(false);
    }
  };

  return (
    <Formik
      initialValues={{ email: '', password: '' }}
      validationSchema={loginSchema}
      onSubmit={handleSubmit}
    >
      {({ isSubmitting, status }) => (
        <Form className="space-y-4">
          <div>
            <Field
              type="email"
              name="email"
              placeholder="Email"
              className="w-full p-2 border rounded"
            />
            <ErrorMessage name="email" component="div" className="text-red-500 text-sm" />
          </div>
          
          <div>
            <Field
              type="password"
              name="password"
              placeholder="Password"
              className="w-full p-2 border rounded"
            />
            <ErrorMessage name="password" component="div" className="text-red-500 text-sm" />
          </div>
          
          {status && <div className="text-red-500 text-sm">{status}</div>}
          
          <button
            type="submit"
            disabled={isSubmitting}
            className="w-full bg-blue-500 text-white p-2 rounded disabled:opacity-50"
          >
            {isSubmitting ? 'Logging in...' : 'Login'}
          </button>
        </Form>
      )}
    </Formik>
  );
}

export function RegisterForm() {
  const { register } = useAuth();
  const router = useRouter();
  const searchParams = useSearchParams();

  const handleSubmit = async (values: { name: string; email: string; password: string }, { setSubmitting, setStatus }: any) => {
    try {
      setStatus('');
      const success = await register(values.email, values.password, values.name);
      
      if (success) {
        const redirect = searchParams.get('redirect') || '/dashboard';
        router.push(redirect);
        router.refresh(); // Ensure proper navigation
      } else {
        setStatus('Registration failed. Please try again.');
      }
    } catch (error) {
      setStatus('An error occurred. Please try again.');
    } finally {
      setSubmitting(false);
    }
  };

  return (
    <Formik
      initialValues={{ name: '', email: '', password: '' }}
      validationSchema={registerSchema}
      onSubmit={handleSubmit}
    >
      {({ isSubmitting, status }) => (
        <Form className="space-y-4">
          <div>
            <Field
              type="text"
              name="name"
              placeholder="Full Name"
              className="w-full p-2 border rounded"
            />
            <ErrorMessage name="name" component="div" className="text-red-500 text-sm" />
          </div>
          
          <div>
            <Field
              type="email"
              name="email"
              placeholder="Email"
              className="w-full p-2 border rounded"
            />
            <ErrorMessage name="email" component="div" className="text-red-500 text-sm" />
          </div>
          
          <div>
            <Field
              type="password"
              name="password"
              placeholder="Password"
              className="w-full p-2 border rounded"
            />
            <ErrorMessage name="password" component="div" className="text-red-500 text-sm" />
          </div>
          
          {status && <div className="text-red-500 text-sm">{status}</div>}
          
          <button
            type="submit"
            disabled={isSubmitting}
            className="w-full bg-green-500 text-white p-2 rounded disabled:opacity-50"
          >
            {isSubmitting ? 'Registering...' : 'Register'}
          </button>
        </Form>
      )}
    </Formik>
  );
}

// hooks/use-auth-redirect.ts
'use client';

import { useAuth } from '@/contexts/auth-context';
import { useRouter } from 'next/navigation';
import { useEffect } from 'react';

export function useAuthRedirect(redirectTo: string = '/login') {
  const { isAuthenticated, loading } = useAuth();
  const router = useRouter();

  useEffect(() => {
    if (!loading && !isAuthenticated) {
      router.push(redirectTo);
    }
  }, [isAuthenticated, loading, router, redirectTo]);

  return { isAuthenticated, loading };
}
